// Generated by gencpp from file custom_msg/custom.msg
// DO NOT EDIT!


#ifndef CUSTOM_MSG_MESSAGE_CUSTOM_H
#define CUSTOM_MSG_MESSAGE_CUSTOM_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace custom_msg
{
template <class ContainerAllocator>
struct custom_
{
  typedef custom_<ContainerAllocator> Type;

  custom_()
    : x1(0.0)
    , y1(0.0)
    , a1(0.0)
    , c1(0)
    , x2(0.0)
    , y2(0.0)
    , a2(0.0)
    , c2(0)
    , x3(0.0)
    , y3(0.0)
    , a3(0.0)
    , c3(0)
    , x4(0.0)
    , y4(0.0)
    , a4(0.0)
    , c4(0)  {
    }
  custom_(const ContainerAllocator& _alloc)
    : x1(0.0)
    , y1(0.0)
    , a1(0.0)
    , c1(0)
    , x2(0.0)
    , y2(0.0)
    , a2(0.0)
    , c2(0)
    , x3(0.0)
    , y3(0.0)
    , a3(0.0)
    , c3(0)
    , x4(0.0)
    , y4(0.0)
    , a4(0.0)
    , c4(0)  {
  (void)_alloc;
    }



   typedef float _x1_type;
  _x1_type x1;

   typedef float _y1_type;
  _y1_type y1;

   typedef float _a1_type;
  _a1_type a1;

   typedef int8_t _c1_type;
  _c1_type c1;

   typedef float _x2_type;
  _x2_type x2;

   typedef float _y2_type;
  _y2_type y2;

   typedef float _a2_type;
  _a2_type a2;

   typedef int8_t _c2_type;
  _c2_type c2;

   typedef float _x3_type;
  _x3_type x3;

   typedef float _y3_type;
  _y3_type y3;

   typedef float _a3_type;
  _a3_type a3;

   typedef int8_t _c3_type;
  _c3_type c3;

   typedef float _x4_type;
  _x4_type x4;

   typedef float _y4_type;
  _y4_type y4;

   typedef float _a4_type;
  _a4_type a4;

   typedef int8_t _c4_type;
  _c4_type c4;





  typedef boost::shared_ptr< ::custom_msg::custom_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::custom_msg::custom_<ContainerAllocator> const> ConstPtr;

}; // struct custom_

typedef ::custom_msg::custom_<std::allocator<void> > custom;

typedef boost::shared_ptr< ::custom_msg::custom > customPtr;
typedef boost::shared_ptr< ::custom_msg::custom const> customConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::custom_msg::custom_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::custom_msg::custom_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::custom_msg::custom_<ContainerAllocator1> & lhs, const ::custom_msg::custom_<ContainerAllocator2> & rhs)
{
  return lhs.x1 == rhs.x1 &&
    lhs.y1 == rhs.y1 &&
    lhs.a1 == rhs.a1 &&
    lhs.c1 == rhs.c1 &&
    lhs.x2 == rhs.x2 &&
    lhs.y2 == rhs.y2 &&
    lhs.a2 == rhs.a2 &&
    lhs.c2 == rhs.c2 &&
    lhs.x3 == rhs.x3 &&
    lhs.y3 == rhs.y3 &&
    lhs.a3 == rhs.a3 &&
    lhs.c3 == rhs.c3 &&
    lhs.x4 == rhs.x4 &&
    lhs.y4 == rhs.y4 &&
    lhs.a4 == rhs.a4 &&
    lhs.c4 == rhs.c4;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::custom_msg::custom_<ContainerAllocator1> & lhs, const ::custom_msg::custom_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace custom_msg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::custom_msg::custom_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::custom_msg::custom_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::custom_msg::custom_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::custom_msg::custom_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::custom_msg::custom_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::custom_msg::custom_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::custom_msg::custom_<ContainerAllocator> >
{
  static const char* value()
  {
    return "1a0f9ebf965faa62489c7c7a11fc5994";
  }

  static const char* value(const ::custom_msg::custom_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x1a0f9ebf965faa62ULL;
  static const uint64_t static_value2 = 0x489c7c7a11fc5994ULL;
};

template<class ContainerAllocator>
struct DataType< ::custom_msg::custom_<ContainerAllocator> >
{
  static const char* value()
  {
    return "custom_msg/custom";
  }

  static const char* value(const ::custom_msg::custom_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::custom_msg::custom_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 x1\n"
"float32 y1\n"
"float32 a1\n"
"int8 c1\n"
"float32 x2\n"
"float32 y2\n"
"float32 a2\n"
"int8 c2\n"
"float32 x3\n"
"float32 y3\n"
"float32 a3\n"
"int8 c3\n"
"float32 x4\n"
"float32 y4\n"
"float32 a4\n"
"int8 c4\n"
;
  }

  static const char* value(const ::custom_msg::custom_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::custom_msg::custom_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.x1);
      stream.next(m.y1);
      stream.next(m.a1);
      stream.next(m.c1);
      stream.next(m.x2);
      stream.next(m.y2);
      stream.next(m.a2);
      stream.next(m.c2);
      stream.next(m.x3);
      stream.next(m.y3);
      stream.next(m.a3);
      stream.next(m.c3);
      stream.next(m.x4);
      stream.next(m.y4);
      stream.next(m.a4);
      stream.next(m.c4);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct custom_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::custom_msg::custom_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::custom_msg::custom_<ContainerAllocator>& v)
  {
    s << indent << "x1: ";
    Printer<float>::stream(s, indent + "  ", v.x1);
    s << indent << "y1: ";
    Printer<float>::stream(s, indent + "  ", v.y1);
    s << indent << "a1: ";
    Printer<float>::stream(s, indent + "  ", v.a1);
    s << indent << "c1: ";
    Printer<int8_t>::stream(s, indent + "  ", v.c1);
    s << indent << "x2: ";
    Printer<float>::stream(s, indent + "  ", v.x2);
    s << indent << "y2: ";
    Printer<float>::stream(s, indent + "  ", v.y2);
    s << indent << "a2: ";
    Printer<float>::stream(s, indent + "  ", v.a2);
    s << indent << "c2: ";
    Printer<int8_t>::stream(s, indent + "  ", v.c2);
    s << indent << "x3: ";
    Printer<float>::stream(s, indent + "  ", v.x3);
    s << indent << "y3: ";
    Printer<float>::stream(s, indent + "  ", v.y3);
    s << indent << "a3: ";
    Printer<float>::stream(s, indent + "  ", v.a3);
    s << indent << "c3: ";
    Printer<int8_t>::stream(s, indent + "  ", v.c3);
    s << indent << "x4: ";
    Printer<float>::stream(s, indent + "  ", v.x4);
    s << indent << "y4: ";
    Printer<float>::stream(s, indent + "  ", v.y4);
    s << indent << "a4: ";
    Printer<float>::stream(s, indent + "  ", v.a4);
    s << indent << "c4: ";
    Printer<int8_t>::stream(s, indent + "  ", v.c4);
  }
};

} // namespace message_operations
} // namespace ros

#endif // CUSTOM_MSG_MESSAGE_CUSTOM_H
