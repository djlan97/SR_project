// Generated by gencpp from file opencv_services/box_and_target_positionResponse.msg
// DO NOT EDIT!


#ifndef OPENCV_SERVICES_MESSAGE_BOX_AND_TARGET_POSITIONRESPONSE_H
#define OPENCV_SERVICES_MESSAGE_BOX_AND_TARGET_POSITIONRESPONSE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace opencv_services
{
template <class ContainerAllocator>
struct box_and_target_positionResponse_
{
  typedef box_and_target_positionResponse_<ContainerAllocator> Type;

  box_and_target_positionResponse_()
    : x1(0.0)
    , y1(0.0)
    , a1(0.0)
    , c1(0)
    , x2(0.0)
    , y2(0.0)
    , a2(0.0)
    , c2(0)
    , x3(0.0)
    , y3(0.0)
    , a3(0.0)
    , c3(0)
    , x4(0.0)
    , y4(0.0)
    , a4(0.0)
    , c4(0)  {
    }
  box_and_target_positionResponse_(const ContainerAllocator& _alloc)
    : x1(0.0)
    , y1(0.0)
    , a1(0.0)
    , c1(0)
    , x2(0.0)
    , y2(0.0)
    , a2(0.0)
    , c2(0)
    , x3(0.0)
    , y3(0.0)
    , a3(0.0)
    , c3(0)
    , x4(0.0)
    , y4(0.0)
    , a4(0.0)
    , c4(0)  {
  (void)_alloc;
    }



   typedef float _x1_type;
  _x1_type x1;

   typedef float _y1_type;
  _y1_type y1;

   typedef float _a1_type;
  _a1_type a1;

   typedef uint8_t _c1_type;
  _c1_type c1;

   typedef float _x2_type;
  _x2_type x2;

   typedef float _y2_type;
  _y2_type y2;

   typedef float _a2_type;
  _a2_type a2;

   typedef uint8_t _c2_type;
  _c2_type c2;

   typedef float _x3_type;
  _x3_type x3;

   typedef float _y3_type;
  _y3_type y3;

   typedef float _a3_type;
  _a3_type a3;

   typedef uint8_t _c3_type;
  _c3_type c3;

   typedef float _x4_type;
  _x4_type x4;

   typedef float _y4_type;
  _y4_type y4;

   typedef float _a4_type;
  _a4_type a4;

   typedef uint8_t _c4_type;
  _c4_type c4;





  typedef boost::shared_ptr< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> const> ConstPtr;

}; // struct box_and_target_positionResponse_

typedef ::opencv_services::box_and_target_positionResponse_<std::allocator<void> > box_and_target_positionResponse;

typedef boost::shared_ptr< ::opencv_services::box_and_target_positionResponse > box_and_target_positionResponsePtr;
typedef boost::shared_ptr< ::opencv_services::box_and_target_positionResponse const> box_and_target_positionResponseConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator1> & lhs, const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator2> & rhs)
{
  return lhs.x1 == rhs.x1 &&
    lhs.y1 == rhs.y1 &&
    lhs.a1 == rhs.a1 &&
    lhs.c1 == rhs.c1 &&
    lhs.x2 == rhs.x2 &&
    lhs.y2 == rhs.y2 &&
    lhs.a2 == rhs.a2 &&
    lhs.c2 == rhs.c2 &&
    lhs.x3 == rhs.x3 &&
    lhs.y3 == rhs.y3 &&
    lhs.a3 == rhs.a3 &&
    lhs.c3 == rhs.c3 &&
    lhs.x4 == rhs.x4 &&
    lhs.y4 == rhs.y4 &&
    lhs.a4 == rhs.a4 &&
    lhs.c4 == rhs.c4;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator1> & lhs, const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace opencv_services

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "305b8cdaf6eafb69d6dc3217db2db095";
  }

  static const char* value(const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x305b8cdaf6eafb69ULL;
  static const uint64_t static_value2 = 0xd6dc3217db2db095ULL;
};

template<class ContainerAllocator>
struct DataType< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "opencv_services/box_and_target_positionResponse";
  }

  static const char* value(const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 x1\n"
"float32 y1\n"
"float32 a1\n"
"uint8 c1\n"
"float32 x2\n"
"float32 y2\n"
"float32 a2\n"
"uint8 c2\n"
"float32 x3\n"
"float32 y3\n"
"float32 a3\n"
"uint8 c3\n"
"float32 x4\n"
"float32 y4\n"
"float32 a4\n"
"uint8 c4\n"
;
  }

  static const char* value(const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.x1);
      stream.next(m.y1);
      stream.next(m.a1);
      stream.next(m.c1);
      stream.next(m.x2);
      stream.next(m.y2);
      stream.next(m.a2);
      stream.next(m.c2);
      stream.next(m.x3);
      stream.next(m.y3);
      stream.next(m.a3);
      stream.next(m.c3);
      stream.next(m.x4);
      stream.next(m.y4);
      stream.next(m.a4);
      stream.next(m.c4);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct box_and_target_positionResponse_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::opencv_services::box_and_target_positionResponse_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::opencv_services::box_and_target_positionResponse_<ContainerAllocator>& v)
  {
    s << indent << "x1: ";
    Printer<float>::stream(s, indent + "  ", v.x1);
    s << indent << "y1: ";
    Printer<float>::stream(s, indent + "  ", v.y1);
    s << indent << "a1: ";
    Printer<float>::stream(s, indent + "  ", v.a1);
    s << indent << "c1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.c1);
    s << indent << "x2: ";
    Printer<float>::stream(s, indent + "  ", v.x2);
    s << indent << "y2: ";
    Printer<float>::stream(s, indent + "  ", v.y2);
    s << indent << "a2: ";
    Printer<float>::stream(s, indent + "  ", v.a2);
    s << indent << "c2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.c2);
    s << indent << "x3: ";
    Printer<float>::stream(s, indent + "  ", v.x3);
    s << indent << "y3: ";
    Printer<float>::stream(s, indent + "  ", v.y3);
    s << indent << "a3: ";
    Printer<float>::stream(s, indent + "  ", v.a3);
    s << indent << "c3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.c3);
    s << indent << "x4: ";
    Printer<float>::stream(s, indent + "  ", v.x4);
    s << indent << "y4: ";
    Printer<float>::stream(s, indent + "  ", v.y4);
    s << indent << "a4: ";
    Printer<float>::stream(s, indent + "  ", v.a4);
    s << indent << "c4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.c4);
  }
};

} // namespace message_operations
} // namespace ros

#endif // OPENCV_SERVICES_MESSAGE_BOX_AND_TARGET_POSITIONRESPONSE_H
